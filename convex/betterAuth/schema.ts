// This file is auto-generated. Do not edit this file manually.
// To regenerate the schema, run:
// `npx @better-auth/cli generate --output undefined -y`

import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export const tables = {
	user: defineTable({
		name: v.string(),
		email: v.string(),
		emailVerified: v.boolean(),
		image: v.optional(v.union(v.null(), v.string())),
		createdAt: v.number(),
		updatedAt: v.number(),
		userId: v.optional(v.union(v.null(), v.string())),
		twoFactorEnabled: v.optional(v.union(v.null(), v.boolean())),
		metadata: v.optional(
			v.union(
				v.null(),
				v.object({}), // empty object
				v.object({
					name: v.object({
						firstName: v.string(),
						lastName: v.string(),
					}),
					bio: v.string(),
					isOnline: v.optional(v.union(v.null(), v.boolean())),
					lunchTime: v.optional(v.union(v.null(), v.string(), v.literal("flexible")))
				})
			)
		),
	})
		.index("email_name", ["email", "name"])
		.index("name", ["name"])
		.index("userId", ["userId"]),
	session: defineTable({
		expiresAt: v.number(),
		token: v.string(),
		createdAt: v.number(),
		updatedAt: v.number(),
		ipAddress: v.optional(v.union(v.null(), v.string())),
		userAgent: v.optional(v.union(v.null(), v.string())),
		userId: v.string(),
		activeOrganizationId: v.optional(v.union(v.null(), v.string())),
	})
		.index("expiresAt", ["expiresAt"])
		.index("expiresAt_userId", ["expiresAt", "userId"])
		.index("token", ["token"])
		.index("userId", ["userId"]),
	account: defineTable({
		accountId: v.string(),
		providerId: v.string(),
		userId: v.string(),
		accessToken: v.optional(v.union(v.null(), v.string())),
		refreshToken: v.optional(v.union(v.null(), v.string())),
		idToken: v.optional(v.union(v.null(), v.string())),
		accessTokenExpiresAt: v.optional(v.union(v.null(), v.number())),
		refreshTokenExpiresAt: v.optional(v.union(v.null(), v.number())),
		scope: v.optional(v.union(v.null(), v.string())),
		password: v.optional(v.union(v.null(), v.string())),
		createdAt: v.number(),
		updatedAt: v.number(),
	})
		.index("accountId", ["accountId"])
		.index("accountId_providerId", ["accountId", "providerId"])
		.index("providerId_userId", ["providerId", "userId"])
		.index("userId", ["userId"]),
	verification: defineTable({
		identifier: v.string(),
		value: v.string(),
		expiresAt: v.number(),
		createdAt: v.number(),
		updatedAt: v.number(),
	})
		.index("expiresAt", ["expiresAt"])
		.index("identifier", ["identifier"]),
	jwks: defineTable({
		publicKey: v.string(),
		privateKey: v.string(),
		createdAt: v.number(),
	}),
	organization: defineTable({
		name: v.string(),
		slug: v.string(),
		logo: v.optional(v.union(v.null(), v.string())),
		createdAt: v.number(),
		metadata: v.optional(v.union(v.null(), v.string(), v.object({
			orgDescription: v.string(),
			strictLunchTime: v.optional(v.union(v.null(), v.boolean())), // If true, the user cannot start lunch break after the lunch time starts (+ grace period), if it's false, the user may start lunch break at any time AFTER the set lunch time that user has.
			contactInfo: v.object({
				mainMail: v.string(),
				hrMail: v.string(),
				websiteUrl: v.optional(v.union(v.null(), v.string())),
				phones: v.optional(v.union(v.null(), v.object({
					mainPhone: v.string(),
					hrPhone: v.string(),
				}))),
			}),
			hours: v.object({
				open: v.string(),
				close: v.string(),
				timezone: v.string(),
				gracePeriod: v.number(),
			}),
			location: v.optional(v.union(v.null(), v.object({
				address: v.string(),
				city: v.string(),
				state: v.string(),
				postalCode: v.string(),
				country: v.string(),
				latitude: v.number(),
				longitude: v.number(),
				formattedAddress: v.string(),
			}))),
		}))),
	})
		.index("name", ["name"])
		.index("slug", ["slug"]),
	member: defineTable({
		organizationId: v.string(),
		userId: v.string(),
		role: v.string(),
		createdAt: v.number(),
		metadata: v.optional(v.union(v.null(), v.object({
			lunchTimeStart: v.optional(v.union(v.null(), v.string(), v.literal("flexible"))),
			lunchTimeDuration: v.optional(v.union(v.null(), v.number(), v.literal("flexible"))),
		}))),
	})
		.index("organizationId", ["organizationId"])
		.index("organizationId_userId", ["organizationId", "userId"])
		.index("userId", ["userId"])
		.index("role", ["role"]),
	invitation: defineTable({
		organizationId: v.string(),
		email: v.string(),
		role: v.optional(v.union(v.null(), v.string())),
		status: v.string(),
		expiresAt: v.number(),
		inviterId: v.string(),
	})
		.index("organizationId", ["organizationId"])
		.index("email", ["email"])
		.index("role", ["role"])
		.index("status", ["status"])
		.index("inviterId", ["inviterId"]),
	twoFactor: defineTable({
		secret: v.string(),
		backupCodes: v.string(),
		userId: v.string(),
	})
		.index("userId", ["userId"]),
	deviceCode: defineTable({
		deviceCode: v.string(),
		userCode: v.string(),
		userId: v.optional(v.union(v.null(), v.string())),
		expiresAt: v.number(),
		status: v.string(),
		lastPolledAt: v.optional(v.union(v.null(), v.number())),
		pollingInterval: v.optional(v.union(v.null(), v.number())),
		clientId: v.optional(v.union(v.null(), v.string())),
		scope: v.optional(v.union(v.null(), v.string())),
		createdAt: v.number(),
		updatedAt: v.number(),
	})
		.index("deviceCode_userCode", ["deviceCode", "userCode"])
		.index("deviceCode_userId", ["deviceCode", "userId"])
		.index("expiresAt", ["expiresAt"])
		.index("status", ["status"]),
	auditLogs: defineTable({
		userId: v.string(),
		action: v.string(),
		timestamp: v.string(),
		ipAddress: v.string(),
		userAgent: v.string(),
		severity: v.string(),
		type: v.string(),
	})
		.index("userId", ["userId"]),
	attendance: defineTable({
		userId: v.string(),
		orgId: v.string(),
		role: v.string(),
		date: v.string(),
		clockIn: v.string(),
		lunchBreakOut: v.optional(v.union(v.null(), v.string())),
		lunchBreakReturn: v.optional(v.union(v.null(), v.string())),
		clockOut: v.optional(v.union(v.null(), v.string())),
		status: v.string(),
		totalWorkSeconds: v.number(),
		totalBreakSeconds: v.number(),
		wasLate: v.boolean(),
		earlyOut: v.optional(v.union(v.null(), v.boolean())),
		timesUpdated: v.number(),
		operation: v.array(v.object({
			id: v.string(),
			type: v.union(v.literal("nfc"), v.literal("webapp"), v.literal("qr")),
			createdAt: v.string(),
		})),
	})
		.index("userId", ["userId"])
		.index("orgId", ["orgId"])
		.index("ordId_date", ["orgId", "date"])
};

const schema = defineSchema(tables);

export default schema;
